## 现有研究调研概况

以下是我们在项目初期调研时所了解到的一些 Linux 上现有 State of the art（SOTA）的 Real-Time scheduling

### RTLinux, RTAI

RTLinux是一个针对标准Linux内核的扩展，旨在为实时应用提供支持。它的开发目的是使Linux内核能够处理实时任务，而不仅仅是传统的非实时任务。RTLinux采用了"中断抽象"的方法。这个方法的核心思想是在标准Linux内核和计算机硬件之间创建一个虚拟硬件层，称为"实时硬件抽象层"（Real-Time Hardware Abstraction Layer，RTHAL）。这个层次实际上只虚拟化了中断。每个来自真实硬件的中断源都被标记为实时或非实时。实时中断由实时子系统处理，而非实时中断由Linux内核管理。这意味着RTLinux能够识别并处理需要实时响应的中断，而将不需要实时响应的中断交给Linux内核处理。

最初，RTAI是RTLinux的一个变种，旨在为Linux内核添加实时特性。尽管RTAI最初是基于RTLinux代码启动的，但两个项目的API（应用程序编程接口）在不同的方向上进行了演化。主要开发者（教授Paolo Mantegazza）对RTAI代码进行了重写，添加了新功能，并创建了一个更完整和强大的系统。因此，RTAI和RTLinux之间存在差异。RTAI社区还开发了Adaptive Domain Environment for Operating Systems（ADEOS）纳米内核，作为RTAI核心的替代方案。ADEOS纳米内核采用了管道方案，其中每个域（操作系统）都有一个预定义的优先级入口。RTAI是最高优先级的域，始终在Linux域之前处理中断，因此能够为任何硬实时活动提供服务，无论是在之前还是在完全抢占非硬实时任务之前。

### OCERA

OCERA是一个欧洲项目，专注于嵌入式实时应用程序。它采用开源方法，旨在为嵌入式系统提供一种综合的执行环境。在OCERA项目中，开发了一个针对Linux 2.4内核的实时调度器。这个调度器旨在允许嵌入式系统实时执行任务，以满足实时性要求。为了尽量减少对内核代码的修改，实时调度器被开发为一个小型补丁（patch）和一个外部可加载的内核模块。补丁的作用是通过一些钩子（hooks）将相关的调度事件导出给外部模块。这种方法的好处是简单灵活，但需要确保在内核中放置这些钩子的位置，这可能会成为挑战。由于钩子的位置可能会随内核版本的变化而发生变化，因此将实时调度器的代码移植到内核的新版本可能会很困难。这是因为内核的不断演进可能会导致钩子的位置和接口发生变化。

### FRESCOR

FRESCOR是一个研究项目，由欧洲联盟的第六框架计划部分资助。项目旨在开发技术和基础设施，以支持实时应用程序的设计和嵌入式系统中的应用，这些应用具有灵活的调度需求。个框架基于AQuoSA（Adaptive Quality of Service-driven Scheduling Architecture）并进一步添加了基于合同的API和一个复杂的中间件，用于指定和管理系统的性能，尽管FRESCOR项目提出了一种复杂的实时框架，但它也面临着上述提到的一些问题和挑战，这包括与内核版本变化相关的问题以及其他可能的挑战。

### Litmus-RT

多核处理器的发展促进了操作系统对多核支持的研究，其中重要的一点是调度算法的研究。由于各个调度算法的测试和性能比较没有一个统一的、合理的实际系统环境，比如是否使用相同体系结构的CPU, 是以应用程序的形式还是以系统内核的形式实现调度算法的测试，这些都造成了结果的可信度不高。因此一种多核实时调度平台--Litmus-RT用于在统一的系统环境下以系统内核的形式实现调度算法的测试和性能的比较。

Litmus-RT平台由美国北卡罗来纳大学教堂山分校计算机科学学院James H. Anderson教授和他的多核实时调度小组研究和开发，其全称是Linux Testbed for MUltiprocessor Scheduling in Real-Time Systems，是一种基于Linux内核、针对多核实时系统背景、测试多核调度算法性能的一种测试平台。 Litmus-RT的设计初衷是在统一的实时系统条件下，对不同类型的多核调度算法的性能、约束性、适用范围等方面进行横向比较，具体为分别使用不同的调度算法，对相同量负载的任务进行调度测试，然后在一些指标数据上比较、分析。Litmus-RT的实现包括三个模块：一、底层数据模块，如任务节点的链接、排序等等使用红黑树表示；二、调度信息跟踪模块，这是基于Linux本身的跟踪功能和时钟功能实现的模块，已经实现了文字和图形两种表现形式，不过对不同的多核调度算法的支持度不足；三、调度算法插件模块，实现了不同类型的、共5种调度算法。Litmus-RT平台还包括其他工具，用于分析调度算法的性能。总而言之，LitmusRT是一个基于Linux的实时调度平台，其提供了一些实现了不同实时调度算法的调度器插件以供我们进行实验，也暴露了一些接口以让我们实现自己的调度插件。

Litmus-RT虽然功能相较全面且支持调度算法自定义，但由于其定位是一套为研究人员测试调度算法而开发的框架，并不面向实际的生产环境，还需要考虑兼容不同的由用户自己编写的调度算法，因此无法做到针对性地深入内核调度机制去优化特定的调度算法，且其早已于2017年停止维护，最新支持的内核版本永远停留在了4.9.30版本，无法支持当前一些新的内核特性。

### Preempt_rt

"Preempt-RT"通常指的是Linux内核的Preemptive Real-Time（抢占式实时）补丁。这个补丁是针对Linux操作系统的一种改进，它提供了更细粒度的抢占式多任务处理能力，从而改善了实时性能。

在标准的Linux内核中，调度器通常是基于分时的，这意味着CPU时间被分配给系统中的各个任务，每个任务运行一定的时间后会被调度器挂起，让其他任务运行。虽然这对于大多数应用来说已经足够，但对于需要严格时间保证的实时任务来说，这种调度方式可能不够。

标准的Linux内核中不可中断的系统调用、中断屏蔽等因素，都会导致系统在时间上的不可预测性，对硬实时限制没有保证。目前，针对 real-time Linux 的修改有两种成功的方案。一是直接修改Linux 内核，使其直接具有 real-time 能力；另一是先运行一个 real-time 核心，然后将Linux 内核作为该 real-time 核心的 idle task来运行。前者则称为 PREEMPT-RT kernel

PREEMPT-RTPatch的核心思想是最小化内核中不可抢占部分的代码，同时将为支持抢占性必须要修改的代码量最小化。对临界区、中断处理函数、关中断等代码序列进行抢占改进。

PREEMPT-RT特性：
- 临界区可抢占
- 中断处理函数可抢占
- "关中断"代码序列可抢占
- 内核中的spinlock和semaphore支持优先级继承
- 延迟操作
- 降低延迟的措施

PREEMPT-RT把Linux变成一个完全可抢占的内核，改变有以下几点：
+ 通过rt_mutex的重新实现使内核里的锁源语可被抢占。以前被如spinlock_t和rwlock_t保护的临界区现在变得可以被抢占了
+ 为内核里的自旋锁和信号量实现优先级继承(PI-Priority Inheritance)
+ 把中断处理器变为可被抢占的内核线程：PREEMPT-RT patch在内核线程上下文中处理软中断处理器

## 本项目的实时调度系统的设计

本项目是基于Linux开发的多核实时调度算法。由于我们队伍三人在这方面的开发经验尚缺，在开发的过程中，更希望参考一些主流的、成熟的、面向多核系统的Real-Time Scheduling的实现。Preempt-rt和Litmus-rt和我们项目做的方向比较符合。但是Preempt-rt和Litmus-rt是互相冲突的，我们需要参考其中一个框架来实现我们自己的多核实时调度系统。

由于Litmus是面向多核的实时调度工具，经过考虑，我们实现的也是多核调度算法，所以策略更接近于Litmus-rt, 实现的时候更多参考Litmus-rt实时调度系统的框架。

在多核调度算法的选择中，我们希望设计一个简洁高效且灵活的算法，所以采用局部性多核调度算法的模式。在局部性多核调度算法框架下改进（优化优先级排序算法，实现考虑阻塞的任务分配机制等），以优化其性能并得到我们自己的调度器。

其他的具体细节会在下文补充。